/* constants */
true: 1 ;
false: 0 ;

/* incrementors */

--: 1 - ;
++: 1 + ;
pred: dup -- ;
succ: dup ++ ;

/* shuffle words */

slip: q< eval q> ;
dip: swap slip ; /* [B] [A] dip  == A [B] */
swapd: q< swap q> ;
dig: swapd swap ; /* c b a -> b a c */
bury: swap swapd ; /* c b a -> a c b */
rot: swap swapd swap ; /* c b a -> a b c */
dupd: q< dup q> ;
over: dupd swap ;
dup2: over over ;
run: dup slip ;
nip: [ drop ] dip ;
tuck: swap over ;
sip: over slip ;       /* b [A*] -> b a* b    (aka keep) */
sipd: q< sip q> ;      /* c b [A*] -> c a* c b */
bi: sipd eval ;
bi2: q< q< dup2 q> eval bury q> eval ;

/* inquisitive */

not: 0 = ;
zero?: 0 = ;
truthy?: zero? not ;
falsey?: zero? ;
!=: = not ;
nzero?: zero? not ;
divisor?: % zero? ;
even?: 2 divisor? ;
odd?: even? not ;

/* comparison */
<=: > not ;
>=: < not ;

sort2: dup2 > [ swap ] ? ;
min: sort2 drop ;
max: sort2 nip ;
clamp: dig max min ;
between?: [ sort2 ] dip swap dupd < bury < and ;

/* binary operators */

bxor: dup2 ~ & bury swap ~ & | ;

/* logical */

and: * truthy? ;
or: + truthy? ;
nand: * zero? ;
nor: + zero? ;

/* branching */

choose: rot [ swap ] ? drop ;
branch: choose eval ;
if: slip ? ;
ifte: slipd branch ;

/* stack */

empty?: depth 0 = ;
one?: depth 1 = ;

tail: q< clr q> ;
head: [ drop ] reduce ;

/* counters */

_runn: dup -- q< [ run q> _runn ] ? ;
runn: _runn q> drop ;

times: runn drop ;
seq: swap times ;

range: dupd swap - [ succ ] seq ;
count: 0 swap ++ [ succ ] seq drop ;

reduce: depth 2 - times ;

sum: [ + ] reduce ;
product: [ * ] reduce ;

/* math */
negitive?: 0 < ;
positive?: 0 > ;
sgn: dup negitive? [ drop -1 ] [ positive? 1 0 choose ] branch ;
abs: dup sgn * ;
sqr: dup * ;
!: dup [ dup -- ! * ] [ drop 1 ] branch ;
nck: dup2 - ! swap ! * [ ! ] dip / ;  /* n choose k */
divrem: [ / ] [ % ] bi2 ;

/* string printing */

space: 32 ;
newline: 10 ;

sp: space putc ;
cr: newline putc ;
print: dup [ putc print ] [ drop ] branch ;
println: print cr ;

ucase?: dup 'a' -- 'z' ++ dig between? ;
lcase?: dup 'A' -- 'Z' ++ dig between? ;

ucase: ucase? [ 32 - ] ? ;
lcase: lcase? [ 32 + ] ? ;