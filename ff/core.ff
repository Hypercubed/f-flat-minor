/* constants */
true: 1 ;
false: 0 ;

/* incrementors */

--: 1 - ;
++: 1 + ;
pred: dup -- ;
succ: dup ++ ;

/* shuffle words */

slip: q< eval q> ;
dip: swap slip ; /* [B] [A] dip  == A [B] */
swapd: q< swap q> ;
dig: swapd swap ; /* c b a -> b a c */
bury: swap swapd ; /* c b a -> a c b */
rot: swap swapd swap ; /* c b a -> a b c */
dupd: q< dup q> ;
over: dupd swap ;
dup2: over over ;
run: dup slip ;

/* inquisitive */

not: 0 = ;
eqz?: 0 = ;
truthy?: eqz? .inline not .inline ;
ne?: = not .inline ;
neqz?: eqz? .inline not .inline ;
divisor?: % eqz? .inline ;
even?: 2 divisor? .inline ;
odd?: even? .inline not ;

/* binary operators */

bxor: dup2 ~ & bury swap ~ & | ;

/* logical */

and: * truthy? ;
or: + truthy? ;
nand: * eqz? ;
nor: + eqz? ;

/* branching */

choose: rot [ swap ] ? drop ;
branch: choose eval ;

/* stack */

empty?: depth 0 = ;
one?: depth 1 = ;

tail: q< clr q> ;
head: &drop reduce ;

/* counters */

repeat_loop: run q> repeat_next ;
repeat_next: dup -- q< [ repeat_loop ] ? ;
repeat: repeat_next q> drop drop ;  

range: dupd swap - [ succ ] swap repeat ;
count: 0 swap ++ [ succ ] swap repeat drop ;

reduce: depth 2 - repeat ;

sum: [ + ] reduce ;
product: [ * ] reduce ;

/* math */
neg?: 0 < ;
pos?: 0 > ;
sgn: dup neg? [ drop -1 ] [ pos? 1 0 choose ] branch ;
abs: dup sgn * ;
sqr: dup * ;
!: dup [ dup -- ! * ] [ drop 1 ] branch ;

/* string printing */

printcr: 10 putc ;
print: dup [ putc print ] [ drop ] branch ;
println: print printcr ;

/* testing */

assert: eqz? [ 0 10 'Failed' println 1 exit ] ? ;