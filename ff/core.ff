/* constants */
TRUE: 1 ;
FALSE: 0 ;

/* incrementors */

--: 1 - ;
++: 1 + ;
pred: dup -- ;
succ: dup ++ ;

/* shuffle words */

slip: q< eval q> ;
dip: swap slip ;
swapd: q< swap q> ;
dig: swapd swap ; /* c b a -> b a c */
bury: swap swapd ; /* c b a -> a c b */
rot: swap swapd swap ; /* c b a -> a b c */
dupd: q< dup q> ;
over: dupd swap ;
dup2: dupd swap dupd swap ;
run: dup slip ;

/* inquisitive */

not: 0 = ;
ne?: = not ;
eqz?: 0 = ;
neqz?: 0 = not ;
divisor?: % eqz? ;
even?: 2 divisor? ;
odd?: even? not ;

/* binary operators */

bxor: dup2 ~ & bury swap ~ & | ;

/* logical */

and: * ;
or: + ;

nand: * eqz? ;
and: nand not ;
nor: + eqz? ;

/* branching */

choose: rot [ swap ] ? drop ;
branch: choose eval ;

/* stack */

empty?: depth 0 = ;
one?: depth 1 = ;

tail: q< clr q> ;
head: &drop reduce ;

/* counters */

repeat_loop: run q> repeat_next ;
repeat_next: dup -- q< &repeat_loop ? ;
repeat: repeat_next q> drop drop ;  

range: dupd swap - &succ swap repeat ;
count: 0 swap ++ &succ swap repeat drop ;

reduce: depth 2 - repeat ;

sum: &+ reduce ;
product: &* reduce ;

/* math */
sqr: dup * ;
!: dup [ dup -- ! * ] [ drop 1 ] branch ;

/* string printing */

print: dup [ putc print ] &drop branch ;
println: print 10 putc ;

/* testing */

assert: eqz? [ 0 10 'Failed println 1 exit ] ? ;